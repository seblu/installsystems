#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
# Started 30/06/2011 by Seblu <seblu@seblu.net>

'''
InstallSystems Command line Tool
'''

import os
import time
import datetime
import argparse
import installsystems
import installsystems.tools as istools
from installsystems.printer import *
from installsystems.repository import Repository
from installsystems.repository import RepositoryManager
from installsystems.repository import RepositoryConfig
from installsystems.image import PackageImage, SourceImage
from installsystems.config import MainConfigFile, RepoConfigFile

def load_repositories(args):
    '''
    Load repositories on a repository manager
    '''
    # remove cache is asked
    if args.no_cache:
        args.cache = None
    # init repo cache object
    repoman = RepositoryManager(args.cache, timeout=args.timeout)
    # register repositories (order matter)
    # load repo configs
    if args.repo_path is not None:
        # from command line
        repoman.register(RepositoryConfig(None, path=args.repo_path))
    else:
        # from config
        for repoconf in RepoConfigFile(args.repo_config).repos:
            # filtering on repository name if present
            if args.repo_filter is not None and repoconf.name != args.repo_filter:
                continue
            repoman.register(repoconf)
    return repoman

def c_new(parser, args):
    '''
    Create a new source image
    '''
    simg = SourceImage.create(args.path)

def c_build(parser, args):
    '''
    Build an image source
    '''
    # build start time
    t0 = time.time()
    # load source image
    simg = SourceImage(args.path)
    # do the job
    simg.build(force=args.force, check=not args.no_check)
    # compute building time
    t1 = time.time()
    dt = int(t1 - t0)
    arrow("Build time: %s" % datetime.timedelta(seconds=dt))

def c_init(parser, args):
    '''
    Create a empty repository
    '''
    # we cannot use load_repositories because repo doesn't exists
    if args.repo_path is not None:
        # from command line
        Repository.create(RepositoryConfig(None, path=args.repo_path))
    else:
        # from config
        for repoconf in RepoConfigFile(args.repo_config).repos:
            # filtering on repository name if present
            if args.repo_filter is not None and repoconf.name != args.repo_filter:
                continue
            Repository.create(repoconf)

def c_add(parser, args):
    '''
    Add an image package into a repository
    '''
    repoman = load_repositories(args)
    if len(repoman) == 0:
        raise Exception("No repository selected")
    elif len(repoman) > 1:
        raise Exception("Please select only one repository")
    repo = repoman[0]
    pkg = PackageImage(args.path)
    repo.add(pkg, delete=not args.preserve)

def c_del(parser, args):
    '''
    Remove an image package from a repository
    '''
    repoman = load_repositories(args)
    if len(repoman) == 0:
        raise Exception("No repository selected")
    elif len(repoman) > 1:
        raise Exception("Please select only one repository")
    repo = repoman[0]
    repo.delete(args.image_name, args.image_version)

def c_install(parser, args):
    '''
    Install an image
    '''
    # looks if arguments is a file or image name
    if istools.pathtype(args.image) == "file" and os.path.isfile(args.image):
        pkg = PackageImage(istools.abspath(args.image))
    elif PackageImage.check_image_name(args.image):
        # get image package
        repoman = load_repositories(args)
        pkg = repoman.get(args.image, args.image_version)
    # add default show help options
    args.subparser.add_argument("-h", "--help", action="help", default=argparse.SUPPRESS,
                                help="show program's version number and exit")
    # Print setup information
    arrow("Installing %s v%s" % (pkg.name, pkg.version))
    # install start time
    t0 = time.time()
    # run parser scripts with parser parser argument
    pkg.run_parser(parser=args.subparser)
    # call parser again, with extended attributes
    arrow("Parsing arguments")
    args = parser.parse_args(namespace=args)
    # run setup scripts
    pkg.run_setup(namespace=args)
    # compute building time
    t1 = time.time()
    dt = int(t1 - t0)
    arrow("Install time: %s" % datetime.timedelta(seconds=dt))

def c_search(parser, args):
    '''
    Search in repository
    '''
    raise NotImplementedError("Not yet implemented")

def c_get(parser, args):
    '''
    Get a remove image in current directory
    '''
    raise NotImplementedError("Not yet implemented")

def c_clean(parser, args):
    '''
    Clean a repository
    '''
    raise NotImplementedError("Not yet implemented")

def c_help(parser, args):
    '''
    Show help
    '''
    parser.print_help()

def c_version(parser, args):
    '''
    Print installsystems version
    '''
    out(installsystems.version)

# Top level argument parsing
p_main = argparse.ArgumentParser()
p_main.add_argument("-V", "--version", action="version",
                    version=installsystems.version,
                    help="show installsystems version")
# exclusive group on debug/quiet
ex_group = p_main.add_mutually_exclusive_group()
ex_group.add_argument('-d', "--debug", action="store_true",
                      help="active debug mode")
ex_group.add_argument('-q', "--quiet", action="store_true",
                      help="active quiet mode")
# common options
p_main.add_argument("-c", "--config", default="installsystems",
                    help="config file path")
p_main.add_argument("-R", "--repo-config", default="repository",
                    help="repository config file path")
p_main.add_argument("-f", "--repo-filter", default=None,
                    help="select repository by name in config files")
p_main.add_argument("-r", "--repo-path", default=None,
                    help="repository path")
p_main.add_argument("-C", "--cache", default=None,
                    help="path of the repository cache")
p_main.add_argument("--no-cache", action="store_true", default=False,
                    help="Not use persistent db caching")
p_main.add_argument("-t", "--timeout", dest="timeout", type=int, default=3,
                    help="download timeout (default 3)")

# create a subparsers for each command
subparsers = p_main.add_subparsers()

# new command parser
p_new = subparsers.add_parser("new", help=c_new.__doc__.lower())
p_new.add_argument("path", help="Path of new image directory")
p_new.set_defaults(func=c_new)

# build command parser
p_build = subparsers.add_parser("build", help=c_build.__doc__.lower())
p_build.add_argument('-f', "--force", action="store_true", default=False,
                     help="overwrite existing image")
p_build.add_argument('-c', "--no-check", action="store_true", default=False,
                     help="do not check compilation before adding scripts")
p_build.add_argument("path", nargs="?", default=".")
p_build.set_defaults(func=c_build)

# init command parser
p_init = subparsers.add_parser("init", help=c_init.__doc__.lower())
p_init.add_argument("repo_filter", nargs="?", default=argparse.SUPPRESS,
                    help="Name or path of a repository to init")
p_init.set_defaults(func=c_init)

# add command parser
p_add =  subparsers.add_parser("add", help=c_add.__doc__.lower())
p_add.add_argument('-p', "--preserve", action="store_true", default=False,
                   help="don't remove image after adding to database")
p_add.add_argument("path")
p_add.set_defaults(func=c_add)

# del command parser
p_del =  subparsers.add_parser("del", help=c_del.__doc__.lower())
p_del.add_argument("image_name")
p_del.add_argument("image_version")
p_del.set_defaults(func=c_del)

# install command parser
p_install = subparsers.add_parser("install", add_help=False,
                                  help=c_install.__doc__.lower())
p_install.add_argument('-f', "--force", action="store_true", default=False,
                       help="overwrite existing image")
p_install.add_argument("-v", "--image-version", type=int, default=None,
                       help="image version")
p_install.add_argument("image", help="image to install (path or name)")
p_install.set_defaults(func=c_install, subparser=p_install)

# get command parser
p_get = subparsers.add_parser("get", help=c_get.__doc__.lower())
p_get.set_defaults(func=c_get)

# search command parser
p_search = subparsers.add_parser("search", help=c_search.__doc__.lower())
p_search.set_defaults(func=c_search)

# clean command parser
p_clean = subparsers.add_parser("clean", help=c_clean.__doc__.lower())
p_clean.set_defaults(func=c_clean)

# help command parser
p_help = subparsers.add_parser("help", help=c_help.__doc__.lower())
p_help.set_defaults(func=c_help)

# version command parser
p_version = subparsers.add_parser("version", help=c_version.__doc__.lower())
p_version.set_defaults(func=c_version)

try:
    # Parse and run
    args = p_main.parse_known_args()[0]
    # set debug and quiet mode before merge
    installsystems.debug = args.debug
    installsystems.quiet = args.quiet
    # load isinstall config
    config = MainConfigFile(args.config, "installsystems")
    config.merge(args)
    # set debug and quiet mode after merge
    installsystems.debug = args.debug
    installsystems.quiet = args.quiet
    if args.func is not c_install:
        args = p_main.parse_args(namespace=args)
    # let's go
    args.func(p_main, args)
except Exception as e:
    error(e)
except KeyboardInterrupt:
    warn("Keyboard Interrupted")
